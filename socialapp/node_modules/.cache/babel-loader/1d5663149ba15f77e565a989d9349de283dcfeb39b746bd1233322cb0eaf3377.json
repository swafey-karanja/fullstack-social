{"ast":null,"code":"/**\n * Response.js\n *\n * Response class provides content decoding\n */\n\nimport Headers from './headers.js';\nimport Body, { clone, extractContentType } from './body.js';\nimport { isRedirect } from './utils/is-redirect.js';\nconst INTERNALS = Symbol('Response internals');\n\n/**\n * Response class\n *\n * Ref: https://fetch.spec.whatwg.org/#response-class\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nexport default class Response extends Body {\n  constructor(body = null, options = {}) {\n    super(body, options);\n\n    // eslint-disable-next-line no-eq-null, eqeqeq, no-negated-condition\n    const status = options.status != null ? options.status : 200;\n    const headers = new Headers(options.headers);\n    if (body !== null && !headers.has('Content-Type')) {\n      const contentType = extractContentType(body, this);\n      if (contentType) {\n        headers.append('Content-Type', contentType);\n      }\n    }\n    this[INTERNALS] = {\n      type: 'default',\n      url: options.url,\n      status,\n      statusText: options.statusText || '',\n      headers,\n      counter: options.counter,\n      highWaterMark: options.highWaterMark\n    };\n  }\n  get type() {\n    return this[INTERNALS].type;\n  }\n  get url() {\n    return this[INTERNALS].url || '';\n  }\n  get status() {\n    return this[INTERNALS].status;\n  }\n\n  /**\n   * Convenience property representing if the request ended normally\n   */\n  get ok() {\n    return this[INTERNALS].status >= 200 && this[INTERNALS].status < 300;\n  }\n  get redirected() {\n    return this[INTERNALS].counter > 0;\n  }\n  get statusText() {\n    return this[INTERNALS].statusText;\n  }\n  get headers() {\n    return this[INTERNALS].headers;\n  }\n  get highWaterMark() {\n    return this[INTERNALS].highWaterMark;\n  }\n\n  /**\n   * Clone this response\n   *\n   * @return  Response\n   */\n  clone() {\n    return new Response(clone(this, this.highWaterMark), {\n      type: this.type,\n      url: this.url,\n      status: this.status,\n      statusText: this.statusText,\n      headers: this.headers,\n      ok: this.ok,\n      redirected: this.redirected,\n      size: this.size,\n      highWaterMark: this.highWaterMark\n    });\n  }\n\n  /**\n   * @param {string} url    The URL that the new response is to originate from.\n   * @param {number} status An optional status code for the response (e.g., 302.)\n   * @returns {Response}    A Response object.\n   */\n  static redirect(url, status = 302) {\n    if (!isRedirect(status)) {\n      throw new RangeError('Failed to execute \"redirect\" on \"response\": Invalid status code');\n    }\n    return new Response(null, {\n      headers: {\n        location: new URL(url).toString()\n      },\n      status\n    });\n  }\n  static error() {\n    const response = new Response(null, {\n      status: 0,\n      statusText: ''\n    });\n    response[INTERNALS].type = 'error';\n    return response;\n  }\n  static json(data = undefined, init = {}) {\n    const body = JSON.stringify(data);\n    if (body === undefined) {\n      throw new TypeError('data is not JSON serializable');\n    }\n    const headers = new Headers(init && init.headers);\n    if (!headers.has('content-type')) {\n      headers.set('content-type', 'application/json');\n    }\n    return new Response(body, {\n      ...init,\n      headers\n    });\n  }\n  get [Symbol.toStringTag]() {\n    return 'Response';\n  }\n}\nObject.defineProperties(Response.prototype, {\n  type: {\n    enumerable: true\n  },\n  url: {\n    enumerable: true\n  },\n  status: {\n    enumerable: true\n  },\n  ok: {\n    enumerable: true\n  },\n  redirected: {\n    enumerable: true\n  },\n  statusText: {\n    enumerable: true\n  },\n  headers: {\n    enumerable: true\n  },\n  clone: {\n    enumerable: true\n  }\n});","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}