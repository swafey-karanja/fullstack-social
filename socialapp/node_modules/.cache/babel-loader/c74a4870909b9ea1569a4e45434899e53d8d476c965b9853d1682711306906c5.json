{"ast":null,"code":"/*! fetch-blob. MIT License. Jimmy WÃ¤rting <https://jimmy.warting.se/opensource> */\n\n// TODO (jimmywarting): in the feature use conditional loading with top level await (requires 14.x)\n// Node has recently added whatwg stream into core\n\nimport './streams.cjs';\n\n// 64 KiB (same size chrome slice theirs blob into Uint8array's)\nconst POOL_SIZE = 65536;\n\n/** @param {(Blob | Uint8Array)[]} parts */\nasync function* toIterator(parts, clone = true) {\n  for (const part of parts) {\n    if ('stream' in part) {\n      yield* ( /** @type {AsyncIterableIterator<Uint8Array>} */part.stream());\n    } else if (ArrayBuffer.isView(part)) {\n      if (clone) {\n        let position = part.byteOffset;\n        const end = part.byteOffset + part.byteLength;\n        while (position !== end) {\n          const size = Math.min(end - position, POOL_SIZE);\n          const chunk = part.buffer.slice(position, position + size);\n          position += chunk.byteLength;\n          yield new Uint8Array(chunk);\n        }\n      } else {\n        yield part;\n      }\n      /* c8 ignore next 10 */\n    } else {\n      // For blobs that have arrayBuffer but no stream method (nodes buffer.Blob)\n      let position = 0,\n        b = /** @type {Blob} */part;\n      while (position !== b.size) {\n        const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE));\n        const buffer = await chunk.arrayBuffer();\n        position += buffer.byteLength;\n        yield new Uint8Array(buffer);\n      }\n    }\n  }\n}\nconst _Blob = class Blob {\n  /** @type {Array.<(Blob|Uint8Array)>} */\n  #parts = [];\n  #type = '';\n  #size = 0;\n  #endings = 'transparent';\n\n  /**\n   * The Blob() constructor returns a new Blob object. The content\n   * of the blob consists of the concatenation of the values given\n   * in the parameter array.\n   *\n   * @param {*} blobParts\n   * @param {{ type?: string, endings?: string }} [options]\n   */\n  constructor(blobParts = [], options = {}) {\n    if (typeof blobParts !== 'object' || blobParts === null) {\n      throw new TypeError('Failed to construct \\'Blob\\': The provided value cannot be converted to a sequence.');\n    }\n    if (typeof blobParts[Symbol.iterator] !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': The object must have a callable @@iterator property.');\n    }\n    if (typeof options !== 'object' && typeof options !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': parameter 2 cannot convert to dictionary.');\n    }\n    if (options === null) options = {};\n    const encoder = new TextEncoder();\n    for (const element of blobParts) {\n      let part;\n      if (ArrayBuffer.isView(element)) {\n        part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));\n      } else if (element instanceof ArrayBuffer) {\n        part = new Uint8Array(element.slice(0));\n      } else if (element instanceof Blob) {\n        part = element;\n      } else {\n        part = encoder.encode(`${element}`);\n      }\n      this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size;\n      this.#parts.push(part);\n    }\n    this.#endings = `${options.endings === undefined ? 'transparent' : options.endings}`;\n    const type = options.type === undefined ? '' : String(options.type);\n    this.#type = /^[\\x20-\\x7E]*$/.test(type) ? type : '';\n  }\n\n  /**\n   * The Blob interface's size property returns the\n   * size of the Blob in bytes.\n   */\n  get size() {\n    return this.#size;\n  }\n\n  /**\n   * The type property of a Blob object returns the MIME type of the file.\n   */\n  get type() {\n    return this.#type;\n  }\n\n  /**\n   * The text() method in the Blob interface returns a Promise\n   * that resolves with a string containing the contents of\n   * the blob, interpreted as UTF-8.\n   *\n   * @return {Promise<string>}\n   */\n  async text() {\n    // More optimized than using this.arrayBuffer()\n    // that requires twice as much ram\n    const decoder = new TextDecoder();\n    let str = '';\n    for await (const part of toIterator(this.#parts, false)) {\n      str += decoder.decode(part, {\n        stream: true\n      });\n    }\n    // Remaining\n    str += decoder.decode();\n    return str;\n  }\n\n  /**\n   * The arrayBuffer() method in the Blob interface returns a\n   * Promise that resolves with the contents of the blob as\n   * binary data contained in an ArrayBuffer.\n   *\n   * @return {Promise<ArrayBuffer>}\n   */\n  async arrayBuffer() {\n    // Easier way... Just a unnecessary overhead\n    // const view = new Uint8Array(this.size);\n    // await this.stream().getReader({mode: 'byob'}).read(view);\n    // return view.buffer;\n\n    const data = new Uint8Array(this.size);\n    let offset = 0;\n    for await (const chunk of toIterator(this.#parts, false)) {\n      data.set(chunk, offset);\n      offset += chunk.length;\n    }\n    return data.buffer;\n  }\n  stream() {\n    const it = toIterator(this.#parts, true);\n    return new globalThis.ReadableStream({\n      // @ts-ignore\n      type: 'bytes',\n      async pull(ctrl) {\n        const chunk = await it.next();\n        chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);\n      },\n      async cancel() {\n        await it.return();\n      }\n    });\n  }\n\n  /**\n   * The Blob interface's slice() method creates and returns a\n   * new Blob object which contains data from a subset of the\n   * blob on which it's called.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @param {string} [type]\n   */\n  slice(start = 0, end = this.size, type = '') {\n    const {\n      size\n    } = this;\n    let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);\n    let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);\n    const span = Math.max(relativeEnd - relativeStart, 0);\n    const parts = this.#parts;\n    const blobParts = [];\n    let added = 0;\n    for (const part of parts) {\n      // don't add the overflow to new blobParts\n      if (added >= span) {\n        break;\n      }\n      const size = ArrayBuffer.isView(part) ? part.byteLength : part.size;\n      if (relativeStart && size <= relativeStart) {\n        // Skip the beginning and change the relative\n        // start & end position as we skip the unwanted parts\n        relativeStart -= size;\n        relativeEnd -= size;\n      } else {\n        let chunk;\n        if (ArrayBuffer.isView(part)) {\n          chunk = part.subarray(relativeStart, Math.min(size, relativeEnd));\n          added += chunk.byteLength;\n        } else {\n          chunk = part.slice(relativeStart, Math.min(size, relativeEnd));\n          added += chunk.size;\n        }\n        relativeEnd -= size;\n        blobParts.push(chunk);\n        relativeStart = 0; // All next sequential parts should start at 0\n      }\n    }\n    const blob = new Blob([], {\n      type: String(type).toLowerCase()\n    });\n    blob.#size = span;\n    blob.#parts = blobParts;\n    return blob;\n  }\n  get [Symbol.toStringTag]() {\n    return 'Blob';\n  }\n  static [Symbol.hasInstance](object) {\n    return object && typeof object === 'object' && typeof object.constructor === 'function' && (typeof object.stream === 'function' || typeof object.arrayBuffer === 'function') && /^(Blob|File)$/.test(object[Symbol.toStringTag]);\n  }\n};\nObject.defineProperties(_Blob.prototype, {\n  size: {\n    enumerable: true\n  },\n  type: {\n    enumerable: true\n  },\n  slice: {\n    enumerable: true\n  }\n});\n\n/** @type {typeof globalThis.Blob} */\nexport const Blob = _Blob;\nexport default Blob;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}