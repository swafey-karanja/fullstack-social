{"ast":null,"code":"/*! formdata-polyfill. MIT License. Jimmy WÃ¤rting <https://jimmy.warting.se/opensource> */\n\nimport C from 'fetch-blob';\nimport F from 'fetch-blob/file.js';\nvar {\n    toStringTag: t,\n    iterator: i,\n    hasInstance: h\n  } = Symbol,\n  r = Math.random,\n  m = 'append,set,get,getAll,delete,keys,values,entries,forEach,constructor'.split(','),\n  f = (a, b, c) => (a += '', /^(Blob|File)$/.test(b && b[t]) ? [(c = c !== void 0 ? c + '' : b[t] == 'File' ? b.name : 'blob', a), b.name !== c || b[t] == 'blob' ? new F([b], c, b) : b] : [a, b + '']),\n  e = (c, f) => (f ? c : c.replace(/\\r?\\n|\\r/g, '\\r\\n')).replace(/\\n/g, '%0A').replace(/\\r/g, '%0D').replace(/\"/g, '%22'),\n  x = (n, a, e) => {\n    if (a.length < e) {\n      throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e} arguments required, but only ${a.length} present.`);\n    }\n  };\nexport const File = F;\n\n/** @type {typeof globalThis.FormData} */\nexport const FormData = class FormData {\n  #d = [];\n  constructor(...a) {\n    if (a.length) throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`);\n  }\n  get [t]() {\n    return 'FormData';\n  }\n  [i]() {\n    return this.entries();\n  }\n  static [h](o) {\n    return o && typeof o === 'object' && o[t] === 'FormData' && !m.some(m => typeof o[m] != 'function');\n  }\n  append(...a) {\n    x('append', arguments, 2);\n    this.#d.push(f(...a));\n  }\n  delete(a) {\n    x('delete', arguments, 1);\n    a += '';\n    this.#d = this.#d.filter(([b]) => b !== a);\n  }\n  get(a) {\n    x('get', arguments, 1);\n    a += '';\n    for (var b = this.#d, l = b.length, c = 0; c < l; c++) if (b[c][0] === a) return b[c][1];\n    return null;\n  }\n  getAll(a, b) {\n    x('getAll', arguments, 1);\n    b = [];\n    a += '';\n    this.#d.forEach(c => c[0] === a && b.push(c[1]));\n    return b;\n  }\n  has(a) {\n    x('has', arguments, 1);\n    a += '';\n    return this.#d.some(b => b[0] === a);\n  }\n  forEach(a, b) {\n    x('forEach', arguments, 1);\n    for (var [c, d] of this) a.call(b, d, c, this);\n  }\n  set(...a) {\n    x('set', arguments, 2);\n    var b = [],\n      c = !0;\n    a = f(...a);\n    this.#d.forEach(d => {\n      d[0] === a[0] ? c && (c = !b.push(a)) : b.push(d);\n    });\n    c && b.push(a);\n    this.#d = b;\n  }\n  *entries() {\n    yield* this.#d;\n  }\n  *keys() {\n    for (var [a] of this) yield a;\n  }\n  *values() {\n    for (var [, a] of this) yield a;\n  }\n};\n\n/** @param {FormData} F */\nexport function formDataToBlob(F, B = C) {\n  var b = `${r()}${r()}`.replace(/\\./g, '').slice(-28).padStart(32, '-'),\n    c = [],\n    p = `--${b}\\r\\nContent-Disposition: form-data; name=\"`;\n  F.forEach((v, n) => typeof v == 'string' ? c.push(p + e(n) + `\"\\r\\n\\r\\n${v.replace(/\\r(?!\\n)|(?<!\\r)\\n/g, '\\r\\n')}\\r\\n`) : c.push(p + e(n) + `\"; filename=\"${e(v.name, 1)}\"\\r\\nContent-Type: ${v.type || \"application/octet-stream\"}\\r\\n\\r\\n`, v, '\\r\\n'));\n  c.push(`--${b}--`);\n  return new B(c, {\n    type: \"multipart/form-data; boundary=\" + b\n  });\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}